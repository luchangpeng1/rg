第一章

1. 软件就是程序，编写软件就是编写程序。（✗）
解释：错误。软件不仅包括程序，还包括相关文档和数据。

2. 软件危机的主要表现是软件需求增加，软件价格上升。（✗）
解释：错误。软件危机的主要表现包括软件开发成本高、质量差、效率低、无法按时交付等问题，而不仅仅是需求增加和价格上升。

3. 软件工程学科出现的主要原因是软件危机的出现。（✓）
解释：正确。软件工程学科正是为了解决软件危机而产生的。

4. 软件工具的作用是为了延长软件产品的寿命。（✗）
解释：错误。软件工具的主要作用是提高软件开发效率和质量。

第二章

1. 瀑布模型的最大优点是将软件开发的各个阶段分得十分清晰。（✗）
解释：错误。虽然瀑布模型确实将开发阶段划分清晰，但这不是它的最大优点。瀑布模型的最大优点是它的规范性和可控性。

2. 螺旋模型是在瀑布模型和增量模型的基础上增加了风险分析活动。（✗）
解释：错误。螺旋模型是在瀑布模型和快速原型模型的基础上增加了风险分析活动，而不是增量模型。

3. 软件工程过程应以软件设计为中心，关键是编写程序。（✗）
解释：错误。软件工程过程应该以需求分析为中心，编程只是其中一个环节。

4. 极限编程属于增量模型。（✗）
解释：错误。极限编程是一种敏捷开发方法，虽然采用迭代增量的方式，但不能简单地归类为增量模型。

第三章

1. 用于需求分析的软件工具，应该能够保证需求的正确性，即验证需求的一致性、完整性、现实性和有效性。（✓）
解释：正确。需求分析工具必须能够验证这些需求特性。

2. 需求分析是开发方的工作，用户的参与度不大。（✗）
解释：错误。需求分析需要用户的深度参与。

3. 需求规格说明书在软件开发中具有重要的作用，它也可以作为软件可行性研究的依据。（✗）
解释：错误。需求规格说明书是在可行性研究之后才产生的文档。

4. 需求分析的主要目的是解决软件开发的具体方案。（✗）
解释：错误。需求分析的主要目的是确定软件要做什么，而不是如何做。

5. 需求规格说明书描述了系统每个功能的具体实现。（✗）
解释：错误。需求规格说明书只描述功能要求，不涉及具体实现。

6. 非功能需求是从各个角度对系统的约束和限制，反映了应用对软件系统质量和特性的额外要求。（✓）
解释：正确。这准确描述了非功能需求的特点。

7. 需求分析阶段的成果主要是需求规格说明书，但该成果与软件设计、编码、测试直至维护关系不大。（✗）
解释：错误。需求规格说明书是整个软件开发过程的基础。

第四章

1. 分层的DFD图可以用于可行性研究阶段，描述系统的物理结构。（✗）
解释：错误。DFD图主要用于需求分析阶段描述系统的功能和数据流，而不是物理结构。

2. 信息建模方法是从数据的角度来建立信息模型的，最常用的描述信息模型的方法是E-R图。（✓）
解释：正确。E-R图是最常用的信息建模工具。

3. 在需求分析阶段主要采用图形工具来描述的原因是图形的信息量大，便于描述规模大的软件系统。（✗）
解释：错误。采用图形工具主要是因为它直观、易于理解和交流。

4. 在一张状态图中只能有一个初态，而终态则可以没有，也可以有多个。（✓）
解释：正确。这是状态图的基本规则。

第五章

1. UML是一种建模语言，是一种标准的表示，是一种方法。（✗）
解释：错误。UML是统一建模语言，是一种标准的表示，但不是一种方法。

2. 类图用来表示系统中的类和类与类之间的关系，它是对系统动态结构的描述。（✗）
解释：错误。类图是对系统静态结构的描述，不是动态结构。

3. 在面向对象的软件开发方法中，每个类都存在其相应的对象，类是对象的实例，对象是生成类的模板。（✗）
解释：错误。类是对象的模板，对象是类的实例，而不是相反。

4. 顺序图用于描述对象是如何交互的，并且重点放在消息序列上。（✓）
解释：正确。顺序图确实主要用于描述对象之间的交互顺序。

5. 继承性是父类和子类之间共享数据结构和消息的机制，这是类之间的一种关系。（✗）
解释：错误。继承性是子类获得父类的属性和方法的机制，而不是共享数据结构和消息的机制。继承表示的是"是一个"(is-a)的关系。

6. 多态性增强了软件的灵活性和重用性，允许用更为明确、易懂的方式去建立通用的软件，多态性和继承性相结合使软件具有更广泛的重用性和可扩充性。（✗）
解释：错误。多态性虽然确实增强了软件的灵活性和重用性，但它并不一定使软件更明确、易懂，反而可能增加理解的难度。

7. 类封装比对象封装更具体、更细致。（✗）
解释：错误。类的封装是在抽象层面，对象封装是在具体实现层面。

8. 用例之间有扩展、使用和组合等几种关系。（✗）
解释：错误。用例之间主要有包含(include)和扩展(extend)两种关系，没有组合关系。

9. 活动图用于显示动作及其结果，着重描述操作实现中所完成的工作，以及用例实例或类中的活动。（✗）
解释：错误。活动图主要用于描述业务流程和并发行为，而不是描述操作实现。

10. UML语言支持面向对象的主要概念，并与具体的开发过程相关。（✗）
解释：错误。UML是独立于开发过程的建模语言。

11. 部署图用于描述系统硬件的物理拓扑结构，以及在此结构上执行的软件。（✓）
解释：正确。这准确描述了部署图的用途。

第六章

1. 模型是对现实的简化，建模是为了更好地理解所开发的系统。（✓）
解释：正确。建模的主要目的就是通过简化来更好地理解系统。

2. 在面向对象的需求分析方法中，建立动态模型是最主要的任务。（✗）
解释：错误。面向对象分析中，对象模型、动态模型和功能模型都同等重要。

3. 在面向对象分析阶段建立的3个模型中，核心模型是功能模型。（✗）
解释：错误。在面向对象分析中，对象模型才是核心模型。

4. 对象模型的描述工具是状态图。（✗）
解释：错误。对象模型的描述工具是类图，状态图是用于描述动态模型的工具。

第七章

1. 模块独立要求高耦合、低内聚。（✗）
解释：错误。模块独立性要求低耦合、高内聚。

2. 软件设计说明书是软件概要设计的主要成果。（✗）
解释：错误。软件设计说明书是详细设计的成果，而不是概要设计的成果。

3. 划分模块可以降低软件的复杂度和工作量，所以应该将模块分得越小越好。（✗）
解释：错误。模块的划分需要适度，过小的模块会增加系统的复杂性。

4. 软件设计中设计复审和设计本身一样重要，其主要作用是避免后期出现高代价的错误。（✓）
解释：正确。设计复审能够及早发现设计中的问题，避免后期修改的高成本。

第八章

1. 系统体系结构的最佳表现形式是一个可执行的软件原型。（✗）
解释：错误。系统体系结构应该用架构图等形式来表现，而不是可执行原型。

2. 软件体系结构的描述是不同项目相关人员之间进行沟通的实现手段。（✓）
解释：正确。软件体系结构描述确实是项目相关人员之间沟通的重要工具。

3. 良好的分层体系结构有利于系统的扩展和维护。（✓）
解释：正确。分层结构可以降低系统各部分的耦合度，提高可维护性和可扩展性。

4. 设计模式是从大量成功实践中总结出来并且被广泛公认的经验和知识。（✓）
解释：正确。设计模式是经过实践检验的最佳解决方案。

第九章

1. 结构化软件设计方法关注于系统的功能，采用自顶向下、逐步求精的设计过程。（✓）
解释：正确。这是结构化设计方法的基本特点。

2. SD法是一种面向数据结构的设计方法，强调程序结构与问题结构相对应。（✗）
解释：错误。SD法是一种面向数据结构的设计方法，强调程序结构要与数据结构相对应，而不是与问题结构相对应。

3. HIPO法既是需求分析方法，又是软件设计方法。（✓）
解释：正确。HIPO法可用于系统分析和设计两个阶段。

4. 面向数据结构设计方法一般包括下列任务：确定数据结构特征；用顺序、选择和重复3种基本形式表示数据等步骤。（✓）
解释：正确。这些都是面向数据结构设计方法的基本步骤。

第十章

1. 在面向对象的设计中，应遵循的设计准则除了模块化、抽象、低耦合和高内聚外，还有信息隐藏。（✓）
解释：正确。信息隐藏是面向对象设计的重要原则之一。

2. 面向对象分析和设计活动是一个多次反复迭代的过程。（✓）
解释：正确。面向对象方法强调迭代和增量式开发。

3. 关系数据库可以完全支持面向对象的概念，面向对象设计中的类可以直接对应到关系数据库中的表。（✗）
解释：错误。关系数据库和面向对象概念存在阻抗不匹配，比如继承、多态等特性在关系数据库中难以直接表达。

4. 面向对象设计是在分析模型的基础上，运用面向对象技术生成软件实现环境下的设计模型。（✓）
解释：正确。面向对象设计是将分析模型转换为可实现的设计模型的过程。

第十一章

1. C语言是一种纯面向对象语言。（✗）
解释：错误。C语言是面向过程的编程语言，不是面向对象语言。

2. 进行程序设计语言的选择时，首先考虑的是应用领域。（✓）
解释：正确。选择编程语言时应首先考虑项目的应用领域特点。

3. 良好的设计风格就是高的编程技巧。（✗）
解释：错误。良好的设计风格不仅包括编程技巧，还包括代码的可读性、可维护性等多个方面。

4. 项目的应用领域是选择程序设计语言的关键因素。（✓）
解释：正确。不同的应用领域对编程语言的要求不同，这是选择语言时的关键考虑因素。

5. FORTRAN、Pascal、C语言和汇编语言都是科学工程计算可选用的语言。（✗）
解释：错误。虽然这些语言都可以用于科学计算，但不是所有场景都适合使用，特别是在现代科学计算中，有更多专门的语言选择。

第十二章

1. 软件测试是对软件规格说明、软件设计和编码的最全面也是最后的审查。（✗）
解释：错误。软件测试不是最后的审查，因为在软件测试之后还有运行维护阶段，而且软件测试贯穿于整个软件开发过程。

2. 如果通过软件测试没有发现错误，则说明软件是正确的。（✗）
解释：错误。测试只能证明存在错误，而不能证明没有错误。

3. 软件测试的目的是尽可能多地发现软件中存在的错误，将它作为纠错的依据。（✓）
解释：正确。测试的主要目的是发现错误，为后续的纠错提供依据。

4. 测试用例由输入数据和预期的输出结果两部分组成。（✓）
解释：正确。一个完整的测试用例必须包含测试输入数据和预期的输出结果。

5. 软件测试的目的是证明软件是正确的。（✗）
解释：错误。软件测试的目的是发现错误，而不是证明软件正确。

第十三章

1. 白盒测试无须考虑模块内部的执行过程和程序结构，只需了解模块的功能即可。（✗）
解释：错误。白盒测试需要考虑模块内部的执行过程和程序结构。

2. 白盒测试是结构测试，主要以程序的内部逻辑为基础设计测试用例。（✓）
解释：正确。白盒测试是基于程序内部逻辑进行的结构测试。

3. 单元测试通常应该先进行"人工走查"，再以白盒法为主、辅以黑盒法进行动态测试。（✓）
解释：正确。这是单元测试的正确步骤和方法。

4. 白盒测试法是一种静态测试方法，主要用于模块测试。（✗）
解释：错误。白盒测试是动态测试方法，不是静态测试。

5. 在等价类划分法中，为了提高测试效率，一个测试用例可以覆盖多个无效等价类。（✗）
解释：错误。一个测试用例只能覆盖一个无效等价类。

6. 功能测试是系统测试的主要内容，检查系统的功能和性能是否与需求规格说明相同。（✓）
解释：正确。功能测试主要验证系统功能是否符合需求规格说明。

第十四章

1. 代码行技术是比较简单的定量估算软件规模的方法。（✓）
解释：正确。代码行数是一种简单直接的软件规模估算方法。

2. 功能点技术依据对软件信息域特性和软件复杂性的评估结果，估算软件规模。（✓）
解释：正确。功能点技术通过评估软件的信息域特性和复杂性来估算规模。

3. 常用的制订进度计划的工具主要有Word和Excel两种。（✗）
解释：错误。进度计划工具不仅限于Word和Excel。

4. 民主制程序员组的一个重要特点是，小组成员完全平等，享有充分民主，通过协商做出技术决策。（✓）
解释：正确。民主制程序员组强调成员平等和协商决策。

5. 主程序员组的两个关键特性是专业化和层次性。（✓）
解释：正确。这是主程序员组的两个主要特征。

6. 现代程序员组中，技术组长既负责技术工作，又负责非技术事务。（✗）
解释：错误。技术组长主要负责技术工作。

7. 风险有两个显著特点，一个是不确定性，另一个是损失。（✓）
解释：正确。这是风险的两个主要特征。

8. 回避风险是指，风险将会发生，就接受后果。（✗）
解释：错误。回避风险是指采取措施避免风险发生。

9. 软件质量保证的措施主要有，基于非执行的测试（也称为复审），基于执行的测试和程序正确性证明。（✓）
解释：正确。这些都是软件质量保证的主要措施。

10. 总体上说，软件工程文档可以分为用户文档、开发文档和管理文档3类。（✓）
解释：正确。这是软件工程文档的三大类。

11. 文档是影响软件可维护性的决定因素。（✓）
解释：正确。文档质量直接影响软件的可维护性。

12. 适应性维护是在软件使用过程中，用户会对软件提出新的功能和性能要求，为了满足这些新的要求而对软件进行修改，使之功能和性能上得到完善和增强的活动。（✗）
解释：错误。这不是适应性维护的定义，这是完善性维护的定义。适应性维护是指随着软件运行环境的改变而修改软件的活动。

13. 进行软件维护活动时，直接修改程序，无须修改文档。（✗）
解释：错误。软件维护时需要同步更新相关文档。

14. 软件生命周期的最后一个阶段是编写软件文档。（✗）
解释：错误。软件文档应该在整个生命周期中持续编写和维护。

15. CMM是指导软件开发的一种面向对象的新技术。（✗）
解释：错误。CMM是软件过程成熟度模型，不是面向对象技术。